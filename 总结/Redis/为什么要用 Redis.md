[TOC]

## 为什么要用 Redis

### 高性能

Redis 是单线程工作模型，但是其如下原因，使得其可以拥有良好的性能：

- Redis 是一个纯内存数据库
- 单线程，避免了频繁的上下文切换造成的开销
- 采用 NIO 的多路复用机制

![Redis 的多路复用](../../images\1536051860336.png)

### 高并发

Redis 是单线程工作模型，因此连接太多时，会造成阻塞。

### 高可用

集群模式可以使得 Redis 具有高可用性。

## Redis 的缺点

- 缓存和数据库双写一致性问题
- 缓存雪崩问题
- 缓存击穿问题
- 缓存的并发竞争问题

## Redis 的应用场景

### String

>  value 类型为 String 时，其容量为 512M。

系统 Tocker 缓存。

计数器。

过期失效。

### Hash

> Value 类型为 Hash 时，其存放的是结构化的对象。

存储结构化的对象。

### List

使用 List 的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。

### Set

因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用 JVM 自带的 Set 进行去重？

因为我们的系统一般都是集群部署，使用 JVM 自带的 Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。

另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。

## Sorted Set

Sorted Set多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。

可以做排行榜应用，取 TOP N 操作。Sorted Set 可以用来做延时任务。最后一个应用就是可以做范围查找。

## Redis 的过期策略以及内存淘汰机制

### 过期策略

定期删除+惰性删除策略。

#### 为什么不用定时删除

定时删除，则需要一个定时器监控全部的 key，过期时则会自动删除，这种方式虽然可以使内存得到及时释放，但是却非常消耗 CPU。

#### 定期删除+惰性删除

Redis 默认每 100 ms 随机抽取一些 key 检测一次，是否有过期的 key 则删除，因此 Redis 的过期机制不能保证过期的 key 一定被删除。

#### 内存淘汰策略

配置：

```xml
maxmemory-policy volatile-lru
```

- noeviction

当内存不足以容纳新写入数据时，新写入操作会报错。

- allkeys-lru

当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 Key。

- allkeys-random

当内存不足以容纳新写入数据时，在键空间中，随机移除某个 Key。

- volatile-lru

当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 Key。

- volatile-random

当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 Key。

- volatile-ttl

当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 Key 优先移除。

PS：如果没有设置 expire 的 Key，不满足先决条件(prerequisites)，那么 volatile-lru，volatile-random 和 volatile-ttl 策略的行为，和 noeviction(不删除) 基本上一致。

## Redis 存在的问题

### 数据库双写一致性问题

分布式系统中的 

Redis 和数据库双写一致性问题

###  

一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。



答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。



另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。



**回答：**首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。



### 



如何应对缓存穿透和缓存雪崩问题

###  

这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。



**缓存穿透，**即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。



缓存穿透解决方案：

- **利用互斥锁，**缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。
- **采用异步更新策略，无论 Key 是否取到值，都直接返回。**Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
- **提供一个能迅速判断请求是否有效的拦截机制，**比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。



**缓存雪崩，**即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。



缓存雪崩解决方案：

- **给缓存的失效时间，**加上一个随机值，避免集体失效。

- **使用互斥锁，**但是该方案吞吐量明显下降了。

- **双缓存。**我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。

  然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。



### 



如何解决 Redis 的并发竞争 Key 问题

###  

这个问题大致就是，同时有多个子系统去 Set 一个 Key。这个时候大家思考过要注意什么呢？



需要说明一下，我提前百度了一下，发现答案基本都是推荐用 Redis 事务机制。



我并不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。



你一个事务中有涉及到多个 Key 操作的时候，这多个 Key 不一定都存储在同一个 redis-server 上。因此，Redis 的事务机制，十分鸡肋。







**如果对这个 Key 操作，不要求顺序**



这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。







**如果对这个 Key 操作，要求顺序**



假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。



期望按照 key1 的 value 值按照 valueA > valueB > valueC 的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。



假设时间戳如下：



系统A key 1 {valueA  3:00}
系统B key 1 {valueB  3:05}
系统C key 1 {valueC  3:10}



那么，假设这会系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。



其他方法，比如利用队列，将 set 方法变成串行访问也可以。总之，灵活变通。





总结



本文对 Redis 的常见问题做了一个总结。大部分是自己在工作中遇到，以及之前面试别人的时候，爱问的一些问题。



另外，不推荐大家临时抱佛脚，真正碰到一些有经验的工程师，其实几下就能把你问懵。最后，希望大家有所收获吧。







https://www.cnblogs.com/rjzheng/p/9310976.html == 分布式锁